directive @hasRole(role: Role!) on FIELD_DEFINITION | MUTATION

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

input CartItem {
  id: String!
  amount: Int!
}

type CartItemType {
  id: String!
  amount: Int!
}

enum CategoryType {
  BAG
  OTHER
  WALLET
  BACKPACK
  SUITCASE
}

scalar Date

type DeleteProductResponse {
  message: String!
}

enum Gender {
  FEMALE
  MALE
  UNISEX
}

type HideProductResponse {
  isHidden: Boolean!
}

enum MainTag {
  STOCK
  NEW
  TOP
  REGULAR
}

type Mutation {
  createOrder(input: NewOrderInput): NewOrderResponse
  createProduct(input: NewProductInput!): NewProductResponse
  updateProduct(input: UpdateProductInput): UpdateProductResponse
  deleteProduct(id: ID!): DeleteProductResponse
  hideProduct(id: ID!, isHidden: Boolean!): HideProductResponse
}

input NewOrderInput {
  name: String!
  surname: String!
  email: String!
  phone: String!
  cityId: String!
  postOfficeId: String!
  supplier: String!
  cartItems: [CartItem!]!
}

type NewOrderResponse {
  message: String!
}

input NewProductInput {
  title: String!
  amount: Int!
  basePrice: Int!
  currentPrice: Int
  gender: Gender!
  instock: Boolean!
  mainTag: MainTag!
  category: CategoryType!
  features: ProductFeaturesInput!
  description: String
}

type NewProductResponse {
  id: ID!
}

type NotFound {
  message: String!
}

type Order {
  id: ID!
  receiverName: String!
  receiverSurname: String!
  receiverEmail: String!
  receiverPhone: String!
  cityId: String!
  postOfficeId: String!
  products: [Product!]!
  status: String!
  cartItems: [CartItemType!]!
  supplier: String!
  createdAt: Date!
}

union OrderByIdResult = Order | NotFound

input OrderFilter {
  status: String!
}

type Pagination {
  totalPages: Int!
  currentPage: Int!
}

input PriceRange {
  lt: Int!
  gt: Int!
}

type PriceRangeType {
  gt: Int!
  lt: Int!
}

type Product {
  id: ID!
  title: String!
  isHidden: Boolean!
  currentPrice: Int!
  basePrice: Int!
  amount: Int!
  instock: Boolean!
  gender: Gender!
  category: CategoryType!
  preview: String!
  images: [String!]!
  tags: [String!]!
  mainTag: MainTag!
  description: String!
  features: ProductFeatures!
}

type ProductFeatures {
  material: String!
  color: String!
  gender: Gender!
  category: CategoryType!
}

input ProductFeaturesInput {
  material: String!
  color: String!
  gender: Gender!
  category: CategoryType!
}

input ProductFilter {
  gender: [Gender]
  isHidden: Boolean
  instock: Boolean
  mainTag: MainTag
  price: PriceRange
  category: [CategoryType]
  page: Int!
}

type ProductFilterType {
  gender: [Gender]
  isHidden: Boolean
  instock: Boolean
  mainTag: MainTag
  price: PriceRangeType
  category: [CategoryType]
  page: Int!
}

union ProductResult = Product | NotFound

type ProductsResponse {
  products: [Product!]!
  priceRange: PriceRangeType!
  pagination: Pagination!
  filter: ProductFilterType!
}

type Query {
  order(id: ID!): OrderByIdResult
  allOrders(input: OrderFilter!): [Order!]!
  product(id: ID!): ProductResult
  allProducts(filter: ProductFilter!): ProductsResponse!
  cartProducts(input: [CartItem!]): [Product!]!
  productsByID(input: [String!]): [Product!]!
  searchProductByName(input: String!): [Product!]!
}

enum Role {
  ADMIN
  USER
}

input UpdateProductInput {
  id: ID!
  title: String!
  amount: Int!
  basePrice: Int!
  currentPrice: Int
  gender: Gender!
  instock: Boolean!
  mainTag: MainTag!
  category: CategoryType!
  description: String
  features: ProductFeaturesInput!
}

type UpdateProductResponse {
  message: String!
}

scalar Upload
